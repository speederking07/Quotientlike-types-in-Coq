W tym rozdziale przedstawiony zostanie sposób wykorzystania typu funkcji do zdefiniowania pewnych typów ilorazowych. Niestety, poniższe przykłady generują więcej problemów niż rozwiązań i w związku z tym są praktycznie bezużyteczne w rzeczywistych aplikacjach. Niemniej jednak, stanowią ciekawy przykład niekonwencjonalnego podejścia do problemu i dlatego zostały zamieszczone w tym krótkim rozdziale.
\section{Utożsamianie elementów przez funkcje}
Na początku pracy wspomnieliśmy, że nie można zdefiniować typu zbiorów oraz multizbiorów dla dowolnego typu bazowego. Jest to prawdą w przypadku typów induktywnych, gdzie kolejność konstruktorów ma znaczenie. Jednakże, możemy wykorzystać wbudowany w praktycznie każdy język programowania typ funkcji. Oczywiście, aby móc w rozsądny sposób rozumować o równościach na funkcjach, będziemy musieli założyć aksjomat ekstensjonalności funkcji\ref{FunExt}. Wprowadzenie tego aksjomatu nie wprowadza sprzeczności do systemu Coq, więc możemy go bezpiecznie dodać z biblioteki standardowej.
\begin{code}
\begin{minted}{coq}
Definition FunExt := forall (A B: Type) (f g: A -> B),
    (forall x: A, f x = g x) -> f = g.
\end{minted}
\caption{Aksjomat ekstensjonalności funkcji w Coqu.}
\label{FunExt}
\end{code}
Po dodaniu tego aksjomatu, funkcje "zapominają" swój wbudowany algorytm sprawdzania równości. Dwie funkcje, które dają takie same wyniki dla całej przestrzeni argumentów, będą sobie równe. Możemy wykorzystać tę właściwość do "zapomnienia" kolejności elementów, nie powołując się na porządek liniowy.
\section{Typy zbiorów i multizbiorów}
Mając już ten koncept w głowie, możemy przejść do zdefiniowania typu zbioru \ref{set} jako funkcji rozstrzygającej, czy element należy do zbioru.
\begin{code}
\begin{minted}{coq}
Definition set (A: Type) : Type := A -> bool.
\end{minted}
\caption{Typ zbioru w Coqu.}
\label{set}
\end{code}
W przeciwieństwie do innych definicji zbiorów przedstawionych w tej pracy, zbiory przedstawione powyżej mogą być potencjalnie nieskończone dla typów, które mają nieskończenie wiele elementów. Pozwala nam to na bardziej elastyczne definicje, jednak kosztem obliczalności podstawowych operacji. Jedną z takich operacji jest np. sprawdzenie, czy zbiór nie jest pusty. Ta operacja w ogólności jest oczywiście nieobliczalna. Możemy w łatwy sposób zdefiniować zbiór liczby rekurencyjnych wywołań (paliwa) potrzebnych, aby dany algorytm zakończył obliczenia. Gdybyśmy mogli sprawdzić, czy taki zbiór jest pusty czy nie, moglibyśmy rozstrzygnąć, czy algorytm kiedyś terminuje, czy nie. Problemu stopu jak wiemy jest jednak problem nierozstrzygalny. W oczywisty sposób, inne operacje, takie jak sprawdzenie, czy dwa zbiory są sobie równe, również będą nierozstrzygalne z tego samego powodu.

Multi-zbiór możemy zdefiniować w bardzo podobny sposób \cite{mset} jak zbiór, zamieniając jedynie typ dwuelementowy \mintinline{coq}{bool} na typ liczb naturalnych \mintinline{coq}{nat}.
\begin{code}
\begin{minted}{coq}
Definition mset (A: Type) : Type := A -> nat.
\end{minted}
\caption{Typ multizbioru w Coqu.}
\label{mset}
\end{code}
Taka implementacja wspiera jedynie takie multizbiory, które mają skończoną liczbę każdego z elementów. Jednakże, można zamienić liczby naturalne na liczby co-naturalne, aby pozbyć się tego ograniczenia. Podobnie jak w przypadku zbiorów, również tu występuje problem z rozstrzyganiem niepustości.
\section{Podstawowe operacje na zbiorach}
Wykazaliśmy, że podstawowe operacje, takie jak sprawdzenie niepustości czy równość, nie są rekurencyjne na potencjalnie nieskończonych zbiorach i multizbiorach. Podobnie jest w przypadku operacji mapowania zbioru, gdyż gdyby istniała taka rekurencyjna funkcja, moglibyśmy dokonać mapowania na typ jednoelementowy wszystkich elementów zbioru i w ten sposób rozstrzygnąć jego niepustość. Zatem zdefiniowane przez nas zbiory nie są ani funktorami, ani monadami w obliczalny sposób. Możemy jednak zdefiniować parę użytecznych funkcji. Sprawdzenie, czy dany element należy do zbioru, jest trywialne, gdyż sam zbiór jest definiowany przez taką funkcją. Możemy także zdefiniować funkcję filtrującą dla zbiorów \cite{set_filter}.
\begin{code}
\begin{minted}{coq}
Definition set_filter {A: Type} (p: A-> bool) (s: set A) : set A :=
  fun x: A => if p x then s x else false.
\end{minted}
\caption{Funckja filtrująca dla zbiorów w Coqu.}
\label{set_filter}
\end{code}
Funkcja ta działa w sposób leniwy, zatem potencjalna nieskończoność zbioru jej nie przeszkadza. W podobny sposób można zdefiniować sumę, przekrój oraz dopełnienie \cite{set_union}.
\begin{code}
\begin{minted}{coq}
Definition set_union {A: Type} (s s': set A) : set A :=
  fun x: A => (s x) || (s' x).

Definition set_intersection {A: Type} (s s': set A) : set A :=
  fun x: A => (s x) && (s' x).

Definition set_complement {A: Type} (s: set A) : set A :=
  fun x: A => negb (s x).
\end{minted}
\caption{Definicja sumy, przekroju oraz dopełniania dla zbiorów w Coqu.}
\label{set_union}
\end{code}
Wykorzystują one osobne sprawdzenie na jednym i drugim zbiorze, a następnie łączą wyniki za pomocą operatorów na typie \mintinline{coq}{bool}. Bardzo podobnie można je również zaimplementować na multizbiorach używając odpowiednio sumy oraz minimum. Operacja dopełniania nie jest oczywiście zdefiniowana dla multizbiorów. Wadą tych leniwych obliczeń jest rosnąca złożoność sprawdzania przynależności do zbioru z każdym kolejnym przekrojem i sumą. Operacje dodania elementu do zbioru da się zdefiniować w rekurencyjny sposób, niestety wymaga ona od typu bazowego posiadania zdefiniowanej rozstrzygalnej równości.
\begin{code}
\begin{minted}{coq}
Definition set_add {A: Type} `{EqDec A} (a: A) (s: set A)  : set A :=
  fun x: A => if eqf x a then true else s x.

Fixpoint list_to_set {A: Type} `{EqDec A} (l: list A) : set A :=
match l with
| []        => fun _ => false
| (h :: l') => set_add h (list_to_set l')
end.
\end{minted}
\caption{Definicja dodawania elementu do zbioru oraz konwersji listy do zbioru w Coqu.}
\label{set_union}
\end{code}
Jeśli takowy mamy, możemy go zdefiniować poprzez porównanie badanego elementu z tym, który dodajemy, a następnie zwrócenie wartości \mintinline{coq}{true}, jeśli są one równe. Wykorzystując tę funkcję, można zdefiniować tworzenie zbioru z listy elementów. Podobnie dla multizbiorów, lecz zamiast zwracania wartości \mintinline{coq}{true}, nakładany jest następnik. Dowody poprawności zdefiniowanych powyżej funkcji można znaleźć w dodatku $FunctionalQuotient.v$.
