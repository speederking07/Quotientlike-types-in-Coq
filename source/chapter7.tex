Quotient types hold significant importance in the field of mathematics formalization and theorem proving. Our thesis highlights that the Coq programming language lacks a built-in method to define quotient types. Hence, we must utilize other constructions with some advantageous properties of quotient types. Our thesis mainly focused on types resembling quotient types, where equality is equivalent to a quotient-defining equivalence relation. We extensively examined different methods of defining such types using normalization functions.

\section{Normalization functions}
The normalization function is a helpful tool for defining quotient-like types. Most quotient types that are frequently used have computable normalization functions that can be utilized for the purpose of defining quotient-like types. However, certain quotient types, such as general unordered pairs or potentially infinite sets, do not have a normalization function. Nevertheless, as demonstrated in the fifth chapter, defining quotient types in Coq is possible in such cases, but it usually comes with many disadvantages. For instance, in the case of sets determining whether the set is empty is an undecidable problem. The class of quotient types with computable normalization function is expansive enough to assess various approaches to constructing quotient-like types.
\section{Subtypes}
Subtypes are helpful in the case of defining types with a subset of elements of the underlying type. They are a dual construction to quotient types and they are already available in Coq. They can be easily applied to restrict an underlying type to a subset of normalized elements, assuming we have a normalization function or predicate.

Defining a subtype with only normalized elements is straightforward. However, proving only a single element is in the subtype for every equivalence class is difficult due to the fact that \mcoq{Prop} sort and proof irrelevance axiom are independent. This makes proving the uniqueness of representations in the general case impossible. One possible solution is to add the proof irrelevance axiom to the system. However, there exist other solutions that do not require additional axioms. For instance, we can squash the normalization predicate to ensure that it is inhabited by, at most, a single witness. Nevertheless, this makes proving other subtype properties much more complicated if not impossible. The final solution is to prove that the underlying type of the subtype has unique identity proofs. In such cases, we can define a quotient-like construction and proof that it satisfies the necessary properties for the uniqueness of representations.

Defining quotient-like constructions using subtypes is easy when types have decidable equality and normalization functions. However, defining operations for this construction can be complicated. One solution is to always normalize the result after applying any operation. Another solution is to prove that the result of the operation is normalized if the input is normalized. This approach is recommended if we refrain from using squashed proofs of normalization for subtype definition. It lets us use properties of functions proven on the underlying type without extra effort.
\section{Traces of normalization functions}
In this thesis, a new method for defining quotient-like types is presented. It involves creating tailor-made inductive types using the traces of the normalization process. When constructing these types, it is easy to prove the uniqueness of their representations.

A challenge in this approach is creating a customized inductive type for a quotient type. In chapter four, we give examples of such constructions based on traces of the normalization function. However, generalizing the process of constructing types solely by examining the normalization function is complex. Only some steps of the normalization process are relevant for creating a quotient-like type, as most steps depend on which unnormalized form was used.

An example of this problem is the normalization process of integers. The final step alone creates a quotient-like type. The inspiration for this thesis was an inductive type of rational numbers based on traces of the Euclidean algorithm. This approach of using traces of normalization function solved a nontrivial problem. The same can be said for traces of normalization of a free monoid. However, it is uncertain whether there is a connection between the traces of the normalization function and some quotient-like types or whether this was a mere coincidence for those examples.

It is unlikely to find a connection between modified sorting functions and the type of lists of differences. This thesis concludes that there is no general way of deriving a normalized representation based on normalization. However, more research is needed to prove this due to the difficulty of establishing a lack of connection.

One of the challenges with the tailor-made quotient-like types is defining basic operations. Although it was easy to define operations for some types, such as free monoids and integers, it proved difficult for most types. As a result, for defining operations, we had to use a naive representation as an intermediary form. To use operations defined for naive representations, we must demonstrate that they maintain the predicate of normalization.

\section{Related and further works}
This thesis covers numerous concepts related to quotient types in Coq. However, it only includes some constructions. For learning the state-of-the-art practical approach to this problem, we recommend reading \cite{PragmaticQT}. This paper explains how to combine the advantages of sentoids and quotient-like types. Another essential paper on this topic is \cite{NormalizedTypes}, which, like this thesis, emphasizes the importance of normalization functions in defining quotient-like types. For those interested in the normalization approach, we also suggest reading \cite{DefinableQuotients}, which discusses the limitations and possibilities of defining quotient types.

The main inspiration for writing this thesis was \cite{Qplus}. This paper describes using traces of the Euclidean algorithm to define the quotient-like type for rational numbers. A similar approach is described in \cite{HereditarilyFS} for Hereditarily Finite Sets. However, we have come to the conclusion that trying to find a universal way of using traces of the normalization function as quotient-like types is a dead end. It is important to note that we can only discover something new by having a small amount of skepticism regarding any information presented to us. Therefore, we encourage readers to verify this conclusion on their own.

We have a couple of recommendations for people interested in quotient types in type theory, regardless of whether they are applicable in Coq or not. Firstly, we suggest reading \cite{DIY_TT}. It is a fantastic introduction to type theory. Moreover, it describes how to define congruence types, a similar concept to quotient types. Next, we recommend reading \cite{Quot_izo}. This paper describes which isomorphisms can and cannot be defined for quotient types. We also suggest reading paper \cite{NuPRL_quot}, which is about quotient types in the NuPRL language. It excellently describes the difference between intentional and extensional approach to quotient types.

\section{Conclusions}
Based on our analysis of various methods for defining quotient-like types in Coq, we have found that their practical usage is limited. Subtypes are more suitable for computational purposes. However, we need to prove the normalization predicate's uniqueness to use them as quotient-like types. Even after that, we need to ensure that the operation preserves the predicate of normalization. This requirement is almost as challenging as proving that the operation respects an equivalence relation. Therefore, sentoids are a better approach in most everyday applications since they can be defined for every equivalence relation without the hardship of defining the normalization function or predicate. However, the downside is that we cannot use equality relations in our prepositions. Another solution for Coq's lack of quotient types is to incorporate them via axioms, as demonstrated in the sixth chapter, or to use a private inductive type, as in the homotopy type theory (HoTT) library for Coq.